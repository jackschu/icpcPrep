notebook_version(2)



input = `
    seeds: 79 14 55 13

    seed-to-soil map:
    50 98 2
    52 50 48

    soil-to-fertilizer map:
    0 15 37
    37 52 2
    39 0 15

    fertilizer-to-water map:
    49 53 8
    0 11 42
    42 0 7
    57 7 4

    water-to-light map:
    88 18 7
    18 25 70

    light-to-temperature map:
    45 77 23
    81 45 19
    68 64 13

    temperature-to-humidity map:
    0 69 1
    1 0 69

    humidity-to-location map:
    60 56 37
    56 93 4
`

input = input.trim()

print(arr = input.split(":").slice(1))

arr = arr.map( a => a.split("\n\n")[0].split("\n").map(x => x.trim()).filter(x => x!==""))

print(arr)


to_arr = (str) => {
    const out = str.split(' ').filter(x => x.trim() !== "").map(Number)
    const found = out.find(x => Number.isNaN(x))
    if(found != null) {
        print("bad input: ", str)
    }
    return out.filter(x => !Number.isNaN(x))
}

seeds = to_arr(arr[0][0])

print(seeds)

maps = arr.slice(1)

stages = maps.map(x => x.map(to_arr).sort((x, y) => x[1]- y[1]))

print(arr)


ranges = []
for (let i = 0; i < seeds.length; i += 2) {
    ranges.push([seeds[i], seeds[i] + seeds[i + 1] - 1])
}

print(ranges)



ans = ranges.map((range) => {
    let cur = [range]
    for (stage of stages) {
        let next = []

        for (range of cur) {
            broken = false
            start = range[0]
            stop = range[1]
            for (rule of stage) {
                rule_start = rule[1]
                rule_stop = rule[1] + rule[2] - 1
                rule_offset = rule[0] - rule[1]
                if (start >= rule_start && stop <= rule_stop) {
                    // contained in rule
                    next.push([start + rule_offset, stop + rule_offset])
                    broken = true
                    break
                } else if (
                    start < rule_start &&
                    stop >= rule_start &&
                    stop <= rule_stop
                ) {
                    // below but overlap
                    next.push([start, rule_start - 1])
                    next.push([rule_start + rule_offset, stop + rule_offset])
                    broken = true
                    break
                } else if (
                    start >= rule_start &&
                    stop > rule_stop &&
                    start <= rule_stop
                ) {
                    // above but overlap
                    next.push([start + rule_offset, rule_stop + rule_offset])
                    start = rule_stop + 1
                } else if (start <= rule_start && stop > rule_stop) {
                    // contains rule
                    next.push([start, rule_start - 1])
                    next.push([
                        rule_start + rule_offset,
                        rule_stop + rule_offset,
                    ])
                    start = rule_stop + 1
                }
            }
            if (!broken) next.push([start, stop])
        }
        cur = [...next]
    }
    return Math.min(...cur.flatMap((n) => n))
})


ans = Math.min(...ans)

print(ans)
